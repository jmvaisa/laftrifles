#!/bin/ksh
##############################################################################
#	Copyright (c) 1993 Fellague Information Tools
#		
#	UNIX SHELL SCRIPT
#	NAME		TITLE
#	cror		rorschach generator for character displays
#
#	SYNOPSIS
#	see USAGE message below
#	
#	DESCRIPTION
#	This rorschach generator script produces symmetrical blobs on
#	character displays.  ANSI and HP cursor addressing modes are
#	supported internally through command line options, and any
#	terminal is supported on systems with the ability to emit
#	cursor addressing sequences through tput (SVR3 and fully
#	compliant descendants, maybe some others).
#
#	RETURN VALUE
#	
#	NOTES / CAVEATS
#		
#	AUTHOR, REVIEWER
#	Leif Fellague Wed Apr  2 12:31:47 MDT 2014
#
#	MODIFICATIONS
#		
##############################################################################
#ident "%Z%MODULE: %P%  VERSION: %I%  %E%  %U%>"

unset DOCOLOR
unset LOOP
unset NOCLEAR
unset RESIZE
unset ANSI
unset EXITCLEAR
unset FLASH
unset UNFLASH
unset RINGBELL
DELAYTIME=0


#ANSI foreground color values
#30	Black
#31	Red
#32	Green
#33	Yellow
#34	Blue
#35	Magenta
#36	Cyan
#37	White

set -A COLARRAY \
	"\033[31m" \
	"\033[32m" \
	"\033[33m" \
	"\033[37m" \
	"\033[36m" \
	"\033[35m" \
	"\033[34m"

typeset -i CURCOLOR COLORCNT
CURCOLOR=0
COLORCNT=${#COLARRAY[*]}
DIRCNT=10

SLEEPTIME=0
PATTSIZE=-1
APPNAME=$(basename $0)

typeset -L1 ALTCHAR
ALTCHAR="#"

USAGE="$APPNAME [options]
options: [-a] [-h] [-p pause-time] [-d delay] [-s size]
         [-l] [-k] [-r] [-t] [-T x] [-c] [-b] [-f]

CURSOR POSITIONING OPTIONS (run MUCH faster by avoiding tput call)
-a = assume ANSI cursor positioning
-h = assume HP cursor positioning

OTHER OPTIONS
-p pause-time = number of seconds between repeats (only meaningful with -l)
-d delay = time to sleep between steps (can use decimal values)
-s size = number of iterations per pattern (default is no limit)
-l = loop mode - repeats until interrupted (only meaningful with -s)
-k = keep screen, do not erase before each iteration
-r = recalculate screen size for each pattern
-t = two-tone, switches between '#' and '.' when drawing
-T = configurable two-tone, switches between '#' and given 'x' when drawing
-c = clear screen on program termination
-C = change colors (uses hard-coded ANSI escape sequences)
-b = ring bell when switching between '#' and '.' (good with -tTC only)
-f = make two-tone characters flash
"

while getopts :p:d:s:lkhartT:cCbf c
do
	case $c in
		a)	ANSI=true ;;
		h)	HP=true ;;
		b)	RINGBELL=$(tput bel) ;;
		c)	EXITCLEAR=true ;;
		C)	DOCOLOR=true; DIRCNT=11 ;;
		f)	FLASH=$(tput blink) ; UNFLASH=$(tput sgr0);;
		k)	NOCLEAR=true ;;
		l)	LOOP=true ;;
		p)	SLEEPTIME=$OPTARG ;;
		d)	DELAYTIME=$OPTARG ;;
		r)	RESIZE=true ;;
		s)	PATTSIZE=$OPTARG ;;
		t)	ALTCHAR=.;;
		T)	ALTCHAR=$OPTARG ;;
		*)	print "$USAGE" >&2
			exit 1
			;;
	esac
done
shift $(expr $OPTIND - 1)

if [ -n "$ANSI" ]
then
RorOut()
{
	ROW=$1
	LCOL=$2
	RCOL=$3
	OUTCHAR=$4
	print "\033[${ROW};${LCOL}H${OUTCHAR}\033[${ROW};${RCOL}H${OUTCHAR}\c"
}
elif [ -n "$HP" ]
then
RorOut()
{
	#ROW=$1
	#LCOL=$2
	#RCOL=$3
	let HROW=$1-1
	let HLCOL=$2-1
	let HRCOL=$3-1
	OUTCHAR=$4
	print \
	"\033&a${HROW}y${HLCOL}C${OUTCHAR}\033&a${HROW}y${HRCOL}C${OUTCHAR}\c"
}
elif tput cup 0 0 >/dev/null 2>&1
then
RorOut()
{
	let ROW=$1
	let LCOL=$2
	let RCOL=$3
	#let ROW=$1-1
	#let LCOL=$2-1
	#let RCOL=$3-1
	OUTCHAR=$4
	tput cup $ROW $LCOL; print "${OUTCHAR}\c"
	tput cup $ROW $RCOL; print "${OUTCHAR}\c"
}
else
	print "\a
ERROR: tput cup not supported on this system. Specify cursor positioning
type for your terminal with command line option (see below).
" >&2
	print "$USAGE" >&2
	exit 1
fi

if [ -z "$DOCOLOR" ]
then
CSwitch()
{
	true
}
elif [ -n "$ANSI" ]
then
CSwitch()
{
	CURCOLOR+=1
	if [ $CURCOLOR -ge $COLORCNT ]
	then
		CURCOLOR=0
	fi
	print "${COLARRAY[$CURCOLOR]}\c"
}
else
CSwitch()
{
	if [ $CURCOLOR -ge 7 ]
	then
		CURCOLOR=1
	else
		CURCOLOR+=1
	fi
	tput setaf $CURCOLOR
}
fi

if [ -z "$EXITCLEAR" ]
then
	if [ -n "$ANSI" ]
	then
	trap 'tput sgr0; tput cnorm; print "\033[${ROWS};0H$COUNTER  \c"; exit' 0 1 2 3 9 15
	elif [ -n "$HP" ]
	then
	trap 'tput sgr0; tput cnorm; print "\033&a${ROWS}y0C$COUNTER  \c"; exit' 0 1 2 3 9 15
	else
	trap 'tput sgr0; tput cnorm; tput cup ${ROWS} 0 ; print "$COUNTER  \c"; exit' 0 1 2 3 9 15
	fi
else
trap 'tput clear; tput sgr0; tput cnorm; exit' 0 1 2 3 9 15
fi


trap 'ReSize' WINCH

ReSize()
{
	print "${CLRSCRN}\c"
	COUNTER=$PATTSIZE
	COLS=$(tput cols)
	ROWS=$(tput lines)
	let ROWS=${ROWS}-1
	let COL2=${COLS}/2
	let ROW=${ROWS}/2
	COL=1
}

if [ -n "$NOCLEAR" ]
then
	CLRSCRN=""
else
	CLRSCRN=$(tput clear)
fi

OUTCHAR=#

ReSize

tput civis

while true
do
	print "${CLRSCRN}\c"
	COUNTER=$PATTSIZE
	let ROW=${ROWS}/2
	COL=1
	CSwitch
	until [ $COUNTER -eq 0 ]
	do
		sleep ${DELAYTIME}
		let DIRECTION=${RANDOM}%${DIRCNT}

		case $DIRECTION in
		0)
			print "${RINGBELL}${UNFLASH}\c"
			OUTCHAR=#
			if [ "$DOCOLOR" ]
			then
				print "${COLARRAY[$CURCOLOR]}\c"
			fi
			;;
		1)
			let ROW=${ROW}+1
			let COL=${COL}-1
			;;
		2)
			let ROW=${ROW}+1
			;;
		3)
			let ROW=${ROW}+1
			let COL=${COL}+1
			;;
		4)
			let COL=${COL}-1
			;;
		5)
			print "${RINGBELL}${FLASH}\c"
			OUTCHAR=$ALTCHAR
			;;
		6)
			let COL=${COL}+1
			;;
		7)
			let ROW=${ROW}-1
			let COL=${COL}-1
			;;
		8)
			let ROW=${ROW}-1
			;;
		9)
			let ROW=${ROW}-1
			let COL=${COL}+1
			;;
		10)
			CSwitch
			;;
		esac

		if [ ${ROW} -gt ${ROWS} ]
		then
			ROW=$ROWS
		fi

		if [ ${ROW} -lt 1 ]
		then
			ROW=1
		fi

		if [ ${COL} -gt ${COL2} ]
		then
			COL=$COL2
		fi

		if [ ${COL} -lt 1 ]
		then
			COL=1
		fi

		let LCOL=${COL2}+1-${COL}
		let RCOL=${COL2}+${COL}
		RorOut $ROW $LCOL $RCOL "$OUTCHAR"
		let COUNTER=${COUNTER}-1
			
	done
	if [ -z "$LOOP" ]
	then
		exit 0
	else
		tput home
		if [ $SLEEPTIME -eq 0 ]
		then
			read NADA
		else
			sleep $SLEEPTIME
		fi
	fi
done
##############################################################################
#	EOF cror
##############################################################################
