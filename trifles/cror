#!/bin/ksh
##############################################################################
#	Copyright (c) 1993 Fellague Information Tools
#		
#	UNIX SHELL SCRIPT
#	NAME		TITLE
#	cror		rorschach generator for character displays
#
#	SYNOPSIS
#	see USAGE message below
#	
#	DESCRIPTION
#	This rorschach generator script produces symmetrical blobs on
#	character displays.  ANSI and HP cursor addressing modes are
#	supported internally through command line options, and any
#	terminal is supported on systems with the ability to emit
#	cursor addressing sequences through tput (SVR3 and fully
#	compliant descendants, maybe some others).
#
#	If allowed to run long enough, the basic invocation will eventually
#	fill the entire screen with "#" characters, but several options allow
#	for more amusing behaviors.  The caller can specify the size at which
#	the pattern stops drawing, whether to generate multiple patterns in a
#	loop (pausing between for either a fixed interval or an operator
#	response), an alternate output character to use to provide a "two-tone"
#	effect (with or without flashing), and even multi-colored output on
#	supported devices.
#
#	RETURN VALUE
#	
#	NOTES / CAVEATS
#		
#	AUTHOR, REVIEWER
#	Leif Fellague Wed Apr  2 12:31:47 MDT 2014
#
#	MODIFICATIONS
#		
##############################################################################
#ident "%Z%MODULE: %P%  VERSION: %I%  %E%  %U%>"

##############################################################################
#	Initialize variables
##############################################################################

unset DOCOLOR
unset LOOP
unset NOCLEAR
unset NOREPOS
unset RESIZE
unset ANSI
unset EXITCLEAR
unset FLASH
unset UNFLASH
unset RINGBELL
DELAYTIME=0


#ANSI foreground color values
#30	Black
#31	Red
#32	Green
#33	Yellow
#34	Blue
#35	Magenta
#36	Cyan
#37	White

set -A COLARRAY \
	"\033[31m" \
	"\033[32m" \
	"\033[33m" \
	"\033[37m" \
	"\033[36m" \
	"\033[35m" \
	"\033[34m"

typeset -i CURCOLOR COLORNBR CSIZE COLRCHARS COUNTER
COLORNBR=${#COLARRAY[*]}
let CURCOLOR=${RANDOM}%${COLORNBR}

DIRCNT=10

SLEEPTIME=0
PATTSIZE=-1
APPNAME=$(basename $0)

typeset -L1 ALTCHAR
ALTCHAR="#"


##############################################################################
#	Process command line options
##############################################################################

USAGE="$APPNAME [options]
options: [-a] [-h] [-p pause-time] [-d delay] [-s size]
         [-l] [-k] [-g] [-r] [-t] [-T x] [-c] [-b] [-f] [-C csize]

CURSOR POSITIONING OPTIONS (run MUCH faster by avoiding tput call)
-a = assume ANSI cursor positioning
-h = assume HP cursor positioning

OTHER OPTIONS
-p pause-time = number of seconds between repeats (only meaningful with -l)
-d delay = seconds to sleep between steps (decimals supported)
-s size = number of iterations per pattern (default is no limit)
-l = loop mode - repeats until interrupted (only meaningful with -s)
-k = keep screen, do not erase before each iteration
-g = grow pattern, like -k but do not recenter cursor
-r = recalculate screen size for each pattern
-t = two-tone, switches between '#' and '.' when drawing
-T = configurable two-tone, switches between '#' and given 'x' when drawing
-c = clear screen on program termination
-C csize = allow color change every <csize> chars (if supported)
-b = ring bell when switching between '#' and '.' (good with -tTC only)
-f = make two-tone characters flash
"

while getopts :p:d:s:lkghartT:cC:bf c
do
	case $c in
		a)	ANSI=true ;;
		h)	HP=true ;;
		b)	RINGBELL=$(tput bel) ;;
		c)	EXITCLEAR=true ;;
		C)	DOCOLOR=true ; DIRCNT=11 ; CSIZE=$OPTARG ;;
		f)	FLASH=$(tput blink) ; UNFLASH=$(tput sgr0);;
		k)	NOCLEAR=true ;;
		g)	NOCLEAR=true ; NOREPOS=true ;;
		l)	LOOP=true ;;
		p)	SLEEPTIME=$OPTARG ;;
		d)	DELAYTIME=$OPTARG ;;
		r)	RESIZE=true ;;
		s)	PATTSIZE=$OPTARG ;;
		t)	ALTCHAR=.;;
		T)	ALTCHAR=$OPTARG ;;
		*)	print "$USAGE" >&2
			exit 1
			;;
	esac
done
shift $(expr $OPTIND - 1)


##############################################################################
#	Function Definitions
##############################################################################

##############################################################################
#	RorOut - This is the character output function.  It accepts the
#	coordinates (left and right) and character to be output, then issues
#	the cursor positioning commands and outputs the character in each
#	position.  Three versions can be defined: one for ANSI, one for HP,
#	and (if neither of those has been specified) the generic "tput"
#	version (defined only if tput cursor positioning appears to work;
#	otherwise, the script errors out).  It should be noted that the
#	generic version is considerably slower because of the need to call
#	tput for each output character.
##############################################################################

if [ -n "$ANSI" ]
then
RorOut()
{
	ROW=$1
	LCOL=$2
	RCOL=$3
	OUTCHAR=$4
	COLRCHARS+=1
	print "\033[${ROW};${LCOL}H${OUTCHAR}\033[${ROW};${RCOL}H${OUTCHAR}\c"
	sleep ${DELAYTIME}
}
elif [ -n "$HP" ]
then
RorOut()
{
	#ROW=$1
	#LCOL=$2
	#RCOL=$3
	let HROW=$1-1
	let HLCOL=$2-1
	let HRCOL=$3-1
	OUTCHAR=$4
	COLRCHARS+=1
	print \
	"\033&a${HROW}y${HLCOL}C${OUTCHAR}\033&a${HROW}y${HRCOL}C${OUTCHAR}\c"
	sleep ${DELAYTIME}
}
elif tput cup 0 0 >/dev/null 2>&1
then
RorOut()
{
	let ROW=$1
	let LCOL=$2
	let RCOL=$3
	#let ROW=$1-1
	#let LCOL=$2-1
	#let RCOL=$3-1
	OUTCHAR=$4
	COLRCHARS+=1
	tput cup $ROW $LCOL; print "${OUTCHAR}\c"
	tput cup $ROW $RCOL; print "${OUTCHAR}\c"
	sleep ${DELAYTIME}
}
else
	print "\a
ERROR: tput cup not supported on this system. Specify cursor positioning
type for your terminal with command line option (see below).
" >&2
	print "$USAGE" >&2
	exit 1
fi

##############################################################################
#	CSwitch - The color switching function.  For ANSI terminals, the
#	script has hard-coded sequences stored in an array; for all other
#	terminals, tput is called to generate a color-setting sequence (no
#	special provision has been made for HP terminals at this time).  In
#	either case, colors are switched through a fixed rotation, and the
#	CSIZE variable controls the minimum number of characters that must be
#	output before switching to a new color is permitted; COLRCHARS keeps
#	track of how many characters have been output in the current color.
##############################################################################

if [ -z "$DOCOLOR" ]
then
CSwitch()
{
	true
}
elif [ -n "$ANSI" ]
then
COLRCHARS=$CSIZE
CSwitch()
{
	if [ $COLRCHARS -lt $CSIZE ]
	then
		return
	fi
	COLRCHARS=0
	CURCOLOR+=1
	if [ $CURCOLOR -ge $COLORNBR ]
	then
		CURCOLOR=0
	fi
	print "${RINGBELL}${COLARRAY[$CURCOLOR]}\c"
}
else
CSwitch()
{
	if [ "$COLRCHARS" -lt "$CSIZE" ]
	then
		return
	fi
	COLRCHARS=0
	if [ $CURCOLOR -ge 7 ]
	then
		CURCOLOR=1
	else
		CURCOLOR+=1
	fi
	print "${RINGBELL}\c"
	tput setaf $CURCOLOR
}
fi

##############################################################################
#	Final output trap - when the script exits, either clear the screen
#	or report the size of the last pattern output.  In either case, reset
#	terminal attributes to "normal" to undo any flashing colors.
##############################################################################

if [ -z "$EXITCLEAR" ]
then
	if [ -n "$ANSI" ]
	then
	trap 'tput sgr0; tput cnorm; print "\033[${ROWS};0H$COUNTER  \c"; exit' 0 1 2 3 9 15
	elif [ -n "$HP" ]
	then
	trap 'tput sgr0; tput cnorm; print "\033&a${ROWS}y0C$COUNTER  \c"; exit' 0 1 2 3 9 15
	else
	trap 'tput sgr0; tput cnorm; tput cup ${ROWS} 0 ; print "$COUNTER  \c"; exit' 0 1 2 3 9 15
	fi
else
trap 'tput clear; tput sgr0; tput cnorm; exit' 0 1 2 3 9 15
fi


##############################################################################
#	Window resize trap - if the shell detects a WINCH signal, the screen
#	is cleared and pattern sizing parameters are reset based on the new
#	screen dimensions.  This keeps cror's "random walk" centered and
#	appropriately bound.
##############################################################################

trap 'ReSize' WINCH

ReSize()
{
	print "${CLRSCRN}\c"
	COUNTER=$PATTSIZE
	COLS=$(tput cols)
	ROWS=$(tput lines)
	let ROWS=${ROWS}-1
	let COL2=${COLS}/2
	let ROW=${ROWS}/2
	COL=1
}

##############################################################################
#	If NOCLEAR has been set, set CLRSCRN to an empty string, otherwise
#	populate it with the sequence output by "tput clear"
##############################################################################

if [ -n "$NOCLEAR" ]
then
	CLRSCRN=""
	tput clear
else
	CLRSCRN=$(tput clear)
fi

OUTCHAR=#

##############################################################################
#	Initial conditions - call ReSize to establish pattern dimensions and
#	use tput to issue a sequence to render the cursor invisible.
##############################################################################

ReSize

tput civis

##############################################################################
#	Repetition loop - this will clear the screen, reset the COUNTER
#	pattern size limit, and re-center the cursor before starting to draw
#	the next pattern.
##############################################################################

while true
do
	print "${CLRSCRN}\c"
	COUNTER=$PATTSIZE
	if [ -z "$NOREPOS" ]
	then
		let ROW=${ROWS}/2
		COL=1
	fi
	CSwitch

	######################################################################
	#	Drawing loop - the cycle keys off of a random number bound by
	#	the number of allowable directional commands (DIRCNT) in
	#	which the drawing cursor may be moved.  As the drawing
	#	cursor is moved to new positions, characters will be output
	#	and the COUNTER decremented until it reaches zero.
	#
	#	The "regular" directions are those on a calculator keypad
	#	(8=up, 2=down, 4=left, 1=down/left, etc.)  The "special"
	#	directions are interpreted as follows:
	#	5 - switch to the alternate output character (& turn on
	#		flashing)
	#	0 - switch the output character to '#' (& turn off flashing)
	#	10 - change to the next color
	######################################################################

	until [ $COUNTER -eq 0 ]
	do
		let DIRECTION=${RANDOM}%${DIRCNT}

		case $DIRECTION in
		0)
			if [ "$ALTCHAR" = "#" ]
			then
				print "${UNFLASH}\c"
			else
				print "${RINGBELL}${UNFLASH}\c"
			fi
			OUTCHAR=#
			if [ "$DOCOLOR" ]
			then
				print "${COLARRAY[$CURCOLOR]}\c"
			fi
			continue
			;;
		1)
			let ROW=${ROW}+1
			let COL=${COL}-1
			;;
		2)
			let ROW=${ROW}+1
			;;
		3)
			let ROW=${ROW}+1
			let COL=${COL}+1
			;;
		4)
			let COL=${COL}-1
			;;
		5)
			if [ "$ALTCHAR" = "#" ]
			then
				print "${FLASH}\c"
			else
				print "${RINGBELL}${FLASH}\c"
			fi
			OUTCHAR=$ALTCHAR
			continue
			;;
		6)
			let COL=${COL}+1
			;;
		7)
			let ROW=${ROW}-1
			let COL=${COL}-1
			;;
		8)
			let ROW=${ROW}-1
			;;
		9)
			let ROW=${ROW}-1
			let COL=${COL}+1
			;;
		10)
			CSwitch
			continue
			;;
		esac

	######################################################################
	#  Boundary checking - keep generated ROW/COL coordinate values within
	#  screen boundaries
	######################################################################

		if [ ${ROW} -gt ${ROWS} ]
		then
			ROW=$ROWS
		fi

		if [ ${ROW} -lt 1 ]
		then
			ROW=1
		fi

		if [ ${COL} -gt ${COL2} ]
		then
			COL=$COL2
		fi

		if [ ${COL} -lt 1 ]
		then
			COL=1
		fi

	######################################################################
	#  Characters will be output to the same row, but in two different
	#  columns to produce a mirror image.  The COL value is combined
	#  with the "center" value in COL2 to produce LCOL for the left and
	#  RCOL for the right.  RorOut is then called to output the drawing
	#  character in the specified locations.
	######################################################################

		let LCOL=${COL2}+1-${COL}
		let RCOL=${COL2}+${COL}
		RorOut $ROW $LCOL $RCOL "$OUTCHAR"
		COUNTER+=-1
			
	done

	######################################################################
	#  If we're not looping through the generation of multiple patterns,
	#  just exit now.  Otherwise, either wait SLEEPTIME seconds if that
	#  was provided, or wait for the operator to hit Enter.
	######################################################################

	if [ -z "$LOOP" ]
	then
		exit 0
	else
		tput home
		if [ $SLEEPTIME -eq 0 ]
		then
			read NADA
		else
			sleep $SLEEPTIME
		fi
	fi
done

##############################################################################
#	EOF cror
##############################################################################
